# XV_6调研情况
~~ 由于本人能力不足，很多东西没办法深刻理解，只能给出大概思路 ~~
## 1
### 操作系统接口
xv6 使用了传统的内核概念 - 一个向其他运行中程序提供服务的特殊程序。每一个运行中程序（称之为进程）都拥有包含指令、数据、栈的内存空间。指令实现了程序的运算，数据是用于运算过程的变量，栈管理了程序的过程调用。
进程通过系统调用使用内核服务。系统调用会进入内核，让内核执行服务然后返回。所以进程总是在用户空间和内核空间之间交替运行。
### 进程和内存
一个XV6进程由用户内存空间和内核进程状态组成，它在不同CPU之间不断切换，中间他们的寄存器被保存或者恢复。一个进程通过fork被创建，fork函数在父进程和子进程中返回的值不同，系统根据返回值决定下一步的操作。其中父进程可以通过wait函数等待子进程执行完成再继续，也可以不等子进程，所以父进程和子进程的结束顺序并不是确定的。子进程可以通过exec函数调用其他功能代码，在这个过程中内存的内容被复制（父进程在创建子进程时，子进程也继承父进程的内存内容）。
### I/O
XV6通过文件描述符把文件抽象，这个行为方便了输入输出重定向过程。同时，write和read的偏移量会在父/子进程中继承，方便了读写操作。
### 管道
pipe方便了各进程之间的通信，它通过绑定进程之间的输入和输出端口实现了进程之间的通信（这个过程依赖文件描述符）。
### 文件系统
XV6的文件系统相当于一个树，目录包含指向文件和其他目录的引用。文件系统的主要由mkdir,chdir,mknod操作，这里不做赘述。文件的引用通过link实现，一个文件可以有多个link,当没有link时（结构体nlink清零），文件将被系统清除。
## 2
### 进程
进程通过页表实现对机器的“独占”，进程向程序提供“看上去”私有的，其他进程无法读写的内存系统（或地址空间），以及一颗“看上去”仅执行该程序的CPU。系统在进程之间的转换实际上就是线程之间的转换，其中进程的state可以在用户态和内核态转换，硬件的优先级随之变化。
计算机开机时，entry函数实现内核的初始化和页表等功能的启动操作，最后跳转到main函数。XV6的第一个进程的代码和普通进程的代码相似，细节直接读文章，我不写了。
## 3
### 页表
XV6的页表分为两层结构，每层都由10位bit控制。CPU通过虚拟地址的高20位找到PTE，然后通过PTE中的PNN和虚拟地址中的低12位（偏移量）找到真实的物理地址。每个页的大小为4096字节。通过PTE的标志位，操作系统可以实现权限和保护机制。每个进程都有自己的页表，而由于页表的限制，每个进程可访问的空间最大为2GB，可能造成不好的影响。而且，由于页目录的大小限制，总进程数也有影响。分配内存时，XV6会通过一个链表维护未被使用的物理页。
## 4
### 陷入，终端和驱动
这个部分和上个学期的LC3相差不多，此处略去细节
## 5
### 锁
xv6 运行在多处理器上，即计算机上有多个单独执行代码的 CPU。这些 CPU 操作同一片地址空间并分享其中的数据结构；xv6 必须建立一种合作机制防止它们互相干扰。即使是在单个处理器上，xv6 也必须使用某些机制来防止中断处理程序与非中断代码之间互相干扰。xv6 为这两种情况使用了相同的低层概念：锁。在一些竞争条件下，不同的CPU调用同一段代码可能会导致意料之外的结果。
    struct list{
        int data;
        struct list *next;
    };

    struct list *list = 0;

    void
    insert(int data)
    {
        struct list *l;
        l = malloc(sizeof *l);
        l->data = data;
        l->next = list;
        list = l;
    }
这个程序中由于多个CPU执行代码的顺序，可能导致请求丢失。为了避免这种情况，就要引入锁。在引入锁的时候，需要考虑为进程分配锁时的竞争，此时需要把分配中的某些操作改变为原子指令防止竞争。由于没有理想、透明的解决方法，我们不得不在函数的使用规范中加入锁。编程者必须保证一个函数不会在持有锁时调用另一个需要获得该锁的函数 f。使用锁的一个难点在于要决定使用多少个锁，以及每个锁保护哪些数据、不变量。不过有几个基本原则。首先，当一个 CPU 正在写一个变量，而同时另一个 CPU 可能读/写该变量时，需要用锁防止两个操作重叠。第二，当用锁保护不变量时，如果不变量涉及到多个数据结构，通常每个数据结构都需要用一个单独的锁保护起来，这样才能维持不变量。由于锁会降低并发度，所以我们一定要避免过度使用锁。当效率不是很重要的时候，完全可以使用单处理器计算机，这样就完全不用考虑锁了。当我们要保护内核的数据结构时，使用一个内核锁还是值得的，当进入内核时必须持有该锁，而退出内核时就释放该锁。如果一段代码要使用多个锁，那么必须要注意代码每次运行都要以相同的顺序获得锁，否则就有死锁的危险。
## 6
### 文件系统
xv6的文件系统分为六层，自下而上分别是：Buffer cache,logging,Inodes and block allocator,Directory inodes,Recursive lookup,File discriptors.
块缓冲是操作系统内核中用于管理磁盘数据访问的重要机制。在 xv6 操作系统中，它被实现为一个双向链表，主要用于缓存磁盘块，提高读写效率，并避免多个进程同时访问同一磁盘块时发生冲突。
#### Buffer cache
缓冲区的三种状态：
B_VALID：缓冲区中存储的内容是有效的，已经从磁盘读取到内存。
B_DIRTY：缓冲区中的数据被修改，需要写回磁盘。
B_BUSY：该缓冲区正在被某个进程使用，其他进程需要等待其释放。
缓冲区的管理：
初始化（binit）：构建包含 NBUF 个元素的双向链表，所有对块缓冲的访问都通过链表进行，而不是直接使用静态数组。
读取（bread）：调用 bget 获取指定扇区的缓冲区，如果未缓存该扇区，则从磁盘读取数据填充缓冲区。
获取缓冲区（bget）：扫描缓冲区链表，查找是否已经缓存了请求的扇区。如果找到可用缓冲区，则标记为 B_BUSY 并返回，否则进入等待或重新扫描寻找可复用的缓冲区。
关键问题：竞争与一致性
bget 需要保证任何时刻对于每个扇区只能有一个缓冲区。
bget 通过双循环机制（先找已有的缓冲区，再找可复用的缓冲区）减少扫描时间，提高效率。
释放缓冲区（brelse）
调用 brelse 释放缓冲区，将其移动到链表头部（最近使用的块放在前面，最久未使用的块放在后面）。
释放 B_BUSY 标志，并唤醒等待该缓冲区的进程。
写入数据（bwrite）
进程修改缓冲区数据后，必须调用 bwrite 标记 B_DIRTY 并写回磁盘，以保证数据一致性。

总结
块缓冲通过链表管理磁盘数据，提高访问效率。
bget 采用双循环策略，优先复用最近使用的缓冲区，减少遍历时间。
brelse 通过调整链表顺序优化最近最少使用（LRU）策略，确保最常用的数据优先被访问。
合理的锁机制和等待策略避免了竞争条件，确保数据一致性和系统稳定性。
#### logging
xv6 通过简单的日志系统来解决文件操作过程当中崩溃所导致的问题。一个系统调用并不直接导致对磁盘上文件系统的写操作，相反，他会把一个对磁盘写操作的描述包装成一个日志写在磁盘中。当系统调用把所有的写操作都写入了日志，它就会写一个特殊的提交记录到磁盘上，代表一次完整的操作。从那时起，系统调用就会把日志中的数据写入磁盘文件系统的数据结构中。在那些写操作都成功完成后，系统调用就会删除磁盘上的日志文件。
每一个系统调用都可能包含一个必须从头到尾原子完成的写操作序列，我们称这样的一个序列为一个会话，虽然他比数据库中的会话要简单得多。任何时候只能有一个进程在一个会话之中，其他进程必须等待当前会话中的进程结束。因此同一时刻日志最多只记录一次会话。

xv6 不允许并发会话，目的是为了避免下面几种问题。假设会话 X 把一个对 i 节点的修改写入了会话中。并发的会话 Y 从同一块中读出了另一个 i 节点，更新了它，把 i 节点块写入了日志并且提交。这就会导致可怕的后果：Y 的提交导致被 X 修改过的 i 节点块被写入磁盘，而 X 此时并没有提交它的修改。如果这时候发生崩溃会使得 X 的修改只应用了一部分而不是全部，从而打破会话是原子的这一性质。有一些复杂的办法可以解决这个问题，但 xv6 直接通过不允许并行的会话来回避这个问题。
下面用比喻的方法解释日志
日志的结构：草稿纸的用法
草稿纸分两块：

开头区域：记录这次修改涉及哪些“账本页”（比如第3页、第5页要改）。
后续区域：实际记录修改内容的草稿（比如把第3页的内容从A改成B）。
关键操作顺序：

先写草稿：把要改的内容全部写到草稿纸上（日志的数据块）。
提交确认：在草稿纸的开头区域写上“本次修改完成”（提交事务）。
正式抄账本：把草稿纸上的修改内容正式写入真正的账本（磁盘文件系统）。
擦除草稿：最后把草稿纸的开头区域清空（计数值清零）。
崩溃恢复：

如果系统在“提交确认”后崩溃，但还没“擦除草稿”，草稿纸上会留着一个非零的计数值。系统重启后看到这个值，就知道需要把草稿纸的内容重新写入账本，保证数据不丢失。

#### block allocator
balloc用于得到一个空闲块（通过循环的方式），bfree用于释放一个块。
#### inodes
磁盘上的 i 节点由结构体 dinode（3676）定义。type 域用来区分文件、目录和特殊文件的 i 节点。如果 type 是0的话就意味着这是一个空闲的 i 节点。nlink 域用来记录指向了这一个 i 节点的目录项，这是用于判断一个 i 节点是否应该被释放的。size 域记录了文件的字节数。addrs 数组用于这个文件的数据块的块号。
内核在内存中维护活动的 i 节点。结构体 inode（3762）是磁盘中的结构体 dinode 在内存中的拷贝。内核只会在有 C 指针指向一个 i 节点的时候才会把这个 i 节点保存在内存中。ref 域用于统计有多少个 C 指针指向它。如果 ref 变为0，内核就会丢掉这个 i 节点。iget 和 iput 两个函数申请和释放 i 节点指针，修改引用计数。i 节点指针可能从文件描述符产生，从当前工作目录产生，也有可能从一些内核代码如 exec 中产生。
如果inode中的address不够用，需要用indirect来连接下一个inode,像链表一样。
#### 目录层
1. 目录的结构：电话簿条目
每个条目（dirent）：
包含两个部分：
名字：最多14个字符（比如"resume.txt"），如果名字较短，后面用\0填充。
i节点号：相当于文件的“身份证号”，通过它找到文件的元数据（大小、数据块位置等）。
特殊标记：如果i节点号为0，表示这个条目是空的（可被新文件占用）。
2. 查找条目：dirlookup（电话簿查询）
想象你要在电话簿中查找“张三”的电话号码：

逐页翻找：
dirlookup 会遍历目录的每个条目，比较名字是否匹配。

如果找到“张三”，就返回他的电话号码（i节点号），并告诉你条目在电话簿中的位置（*poff）。
如果没找到，返回错误。
避免死锁的机制：

假设电话簿（目录）被锁住了，但你需要同时查找“张三”和“李四”。
dirlookup 返回的i节点不会被锁，因为如果直接锁上它，可能导致重复锁（比如查找当前目录.时，目录和自己的i节点都被锁，造成死锁）。
正确做法：先解锁目录，再锁上找到的i节点，保证一次只持有一个锁。
3. 添加新条目：dirlink（电话簿登记）
假设你要在电话簿中登记“李四”的电话号码：

检查是否已存在：

dirlink 会先遍历所有条目，确保“李四”的名字没有被登记过。
如果已经存在，返回错误（“名字重复”）。
找到空白位置：

如果发现一个空条目（i节点号为0），标记这个位置为“李四”的登记处。
如果电话簿已满，就在末尾新增一页（扩展目录大小），然后写入新条目。
写入新条目：

在空白位置写入“李四”的名字和i节点号，完成登记。
#### 路径名称
路径名解析：像快递员送包裹
在操作系统中，路径名（如/home/user/file.txt）的作用类似于快递地址，告诉系统如何一步步找到目标文件。xv6 的路径解析函数（如 namei）就像快递员，按地址逐级派送。

1. 解析路径的步骤
假设你要送快递到地址：“北京市/海淀区/中关村大街1号/张三”，流程如下：

确定起点：

如果地址以/开头（绝对路径），快递员从“北京市”仓库（根目录）出发。
否则，从当前位置（相对路径，如“当前在朝阳区”）出发。
（对应代码中的 namex 函数处理路径起始点）
逐级查找：

拆解地址为多个部分：北京市 → 海淀区 → 中关村大街1号 → 张三。
每级目录都需打开对应的“仓库门”（通过 dirlookup 查找目录条目）。
如果中间某一级不是目录（比如“中关村大街1号”是个文件而非仓库），则派送失败。
处理最终目标：

如果是 nameiparent（查找父目录），快递员会在“中关村大街1号”停下，记录“张三”这个名字，但不派送进去。
否则，继续进入最后一级，找到“张三”的包裹（文件i节点）。
2. 锁的机制：防止中途被修改
锁住当前目录：在查找每一级目录时，快递员会暂时锁住当前仓库门（i节点锁），确保查找过程中仓库结构不被修改（如其他进程删除或新增条目）。
解锁并进入下一级：找到下一级目录后，解锁当前仓库门，再锁住下一级，避免死锁（比如两个快递员互相等待对方解锁）。
#### 文件描述符
1. 文件表与引用计数
全局文件表（ftable）：
类似图书馆的借阅登记册，记录所有被借出的资源。每个资源对应一个 file 结构体，包含：

资源类型：是书（文件i节点）还是光盘（管道）。
借阅权限：可读、可写（如 readable 和 writable）。
借阅次数：引用计数（ref），记录有多少张借书卡指向该资源。
借书卡（文件描述符）：

每调用一次 open 或 dup，相当于复制一张借书卡，增加引用计数。
close 相当于还卡，减少引用计数。当计数归零时，资源真正归还（释放i节点或管道）。
2. 读写操作的管理
读文件：

检查借书卡是否有“可读”权限。
根据资源类型调用不同操作：
文件：从i节点的数据块中读取，并更新读写偏移（下次从这继续读）。
管道：直接从管道缓冲区读取，无偏移概念。
写文件：

类似读操作，但需要“可写”权限。
多个进程同时写文件时，可能交替写入（如进程A写“Hello”，进程B写“World”，最终文件内容可能是“HWeolrllod”）。
# 关于FAT32
FAT32（File Allocation Table 32）是一种由微软在1996年推出的文件系统格式，主要用于管理存储设备上的文件和目录。它是FAT文件系统家族的成员，继承并扩展了FAT12和FAT16的功能。
基本概念：
簇（cluster）： FAT32使用簇作为数据分配的基本单位。一个簇由多个连续的扇区组成，簇的大小通常为2的整数次幂个扇区。簇的编号从2开始，每个簇都有唯一的地址编号。 
文件分配表（FAT）： FAT32的核心是文件分配表，它记录了每个簇的使用情况和簇链信息。每个文件或目录都由一个或多个簇组成，FAT表用于指示这些簇的链接关系。 
结构组成：
引导扇区（Boot Sector）： 位于分区的第一个扇区，包含文件系统的基本信息，如每簇扇区数、FAT表数量、保留扇区数等。 
文件系统信息扇区（FS Info Sector）： 记录数据区中空闲簇的数量及下一个空闲簇的簇号，通常位于引导扇区之后的一个扇区。 
文件分配表（FAT）： 通常有两份FAT表，FAT1是主表，FAT2是备份。它们由格式化程序在对分区进行格式化时创建。 
根目录区（Root Directory Region）： 存储根目录的目录项信息，每个目录项记录文件或目录的名称、大小、起始簇号等。 
数据区（Data Region）： 存放实际的文件和目录数据，由多个簇组成。
工作原理：
文件存储： 当创建一个文件时，系统会在数据区分配一个或多个簇，并在FAT表中记录这些簇的链接关系。
文件读取： 系统通过目录项获取文件的起始簇号，然后根据FAT表的链接信息逐簇读取文件数据。
文件删除： 删除文件时，系统将目录项标记为删除状态，并在FAT表中将对应的簇标记为未使用，但实际数据并未被立即清除。 
优点：
兼容性强： 广泛支持于各种操作系统和设备。
结构简单： 易于实现和维护。
缺点：
单个文件大小限制： 不支持大于4GB的单个文件。
缺乏安全性和权限控制： 无法对文件和目录设置细粒度的访问控制。
簇链分配效率低： 对于大文件，簇链管理可能导致性能下降。
总体而言，FAT32作为一种较早期的文件系统，因其兼容性和简单性，仍在一些场景中使用。然而，对于需要处理大文件或需要高级安全特性的场景，现代文件系统（如NTFS、exFAT等）可能更为适用。
参考网站：
XV6部分
https://th0ar.gitbooks.io/xv6-chinese/content/
FAT32部分
https://www.cnblogs.com/liwen01/p/18204782
https://blog.csdn.net/boilling/article/details/141329641